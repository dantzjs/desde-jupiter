---
title: 'Fundamentos de Arquitectura de Software'
description: "Este an√°lisis detallado explora c√≥mo estos principios fundamentales influyen en el dise√±o y desarrollo exitoso de software de alto rendimiento"
author: "Jos√© D. Guti√©rrez"
image:
  url: "/event-storming.jpg"
  alt: "featured image"
tags: ["Learning", "Metodologies", "Architecture"]
created: 2023-11-07
---

import { Image } from 'astro:assets';
import mvc from '@assets/images/mvc.png';

**¬°Hola desde J√∫piter!** üññ

La **Arquitectura de Software** define la estructura de un sistema, todos sus elementos o partes y c√≥mo estos deben interactuar entre s√≠. En contraste, no es muy diferente de un plano estructural de un edificio.

La finalidad del dise√±o de una arquitectura es ofrecer una estructura que nos permita identificar todos los elementos de nuestro sistema y las reglas involucradas para facilitar la construcci√≥n, mantenimiento y evoluci√≥n. Permite pensar en la soluci√≥n del problema antes de entrar a la fase de desarrollo.

Para esto primero es necesario **conocer y entender los requerimientos** en la fase de an√°lisis. Por cierto, <a href="/notas/event-storming">Event Storming</a> puede ayudarnos con eso.

En la fase de dise√±o ya podemos enfocarnos en c√≥mo estructurar la soluci√≥n aplicando **Patrones de Arquitectura** o tambi√©n llamados **Estilos de Arquitectura** (No confundir con Patrones de Dise√±o).  

## Principios

Estos patrones siguen 3 principios b√°sicos:

### Abstracci√≥n

La idea de la arquitectura consiste en la abstracci√≥n, donde se **simplifica la complejidad del sistema** al dividirlo en elementos m√°s peque√±os y manejables. Estos elementos interact√∫an entre s√≠ de una forma consistente y predecible.

### Separaci√≥n de Responsabilidades

Cada elemento o componente del sistema debe tener bien definida su responsabilidad y no debe hacer tareas que escapen de su propio contexto. Es decir, **cada elemento tiene su propia razon de ser**.

### Reusabilidad

El principio DRY (**Dont Repeat Yourself**, no te repitas a ti mismo) fomenta la idea de estructurar o ‚Äúencapsular‚Äù elementos de forma que permita ser utilizado en varios lugares dentro de la aplicaci√≥n **evitando la duplicaci√≥n de c√≥digo**.

Podemos entender mejor estos principios si analizamos un patr√≥n cl√°sico como lo es el **Patr√≥n MVC**. Este patr√≥n consiste en dividir un sistema en 3 componentes:

- **Modelo**: Contiene el acceso a datos y toda la l√≥gica de la aplicaci√≥n
- **Vista**: La interfaz gr√°fica con la cual el usuario interact√∫a
- **Controlador**: Intermediario entre la Vista y Modelo. Se encarga de transportar los datos

Por ejemplo, supongamos una aplicaci√≥n sencilla de ordenes y pedidos que utiliza una API REST para comunicarse:

<Image src={mvc} alt="MVC Flow"/>

El flujo funcional es:

1. El usuario desde una interfaz gr√°fica interact√∫a con la aplicaci√≥n y decide crear un nuevo pedido.
2. **La Vista** llama a un endpoint */orders* que se encuentra en el **Controlador**.
3. Este controlador recibe los datos enviados desde la vista y se los env√≠a al **Modelo**.
4. El modelo procesa los datos del pedido, almacena en base de datos y retorna la respuesta al controlador.
5. El controlador retorna la respuesta del Modelo a la vista para ser actualizada y mostrarle al usuario ‚ÄúSu pedido ha sido creado‚Äù. 

Aqu√≠ podemos notar los 3 principios aplicados:

1. **Abstracci√≥n**: La complejidad del sistema de simplific√≥ a √∫nicamente 3 componentes
2. **Separaci√≥n de responsabilidades**: Los 3 componentes tienen bien definida su responsabilidad. La Vista muestra los datos, el Controlador los transporta y el Modelo los procesa seg√∫n la l√≥gica de negocio
3. **Reusabilidad**: Al estar separados en componentes y tener una responsabilidad definida, es f√°cil reutilizar c√≥digo. El mismo modelo puede ser utilizado por varios controladores, o el mismo controlador puede ser usado por m√°s de una vista.

## Prop√≥sito

La arquitectura de Software aplica diversos patrones, t√©cnicas y conceptos con la intenci√≥n de que nuestro sistema sea funcional, escalable en el tiempo, f√°cil de probar, seguro y con buen rendimiento. Lo que se traduce en:

Una arquitectura bien dise√±ada **permite que el software crezca de manera eficiente**, tanto en t√©rminos de rendimiento como de funcionalidad, a medida que se agregan m√°s usuarios o se requieren nuevas caracter√≠sticas.

Un dise√±o adecuado f**acilita la correcci√≥n de errores, actualizaciones y modificaciones** sin afectar el funcionamiento general del sistema.

La arquitectura debe ser eficiente en t√©rminos de rendimiento para **proporcionar una experiencia de usuario √≥ptima**. Optimizar el uso de recursos es clave.

Si bien es mucho m√°s que solo eso, esto ser√≠a lo esencial que buscamos tener en cualquier software que queramos desarrollar.


## Sin embargo‚Ä¶

Existen muchos patrones arquitect√≥nicos, y cada patr√≥n puede implementarse de muchas formas. Cu√°l patr√≥n elegir y c√≥mo aplicarlo depende de un buen an√°lisis de los requerimientos, la experiencia y toma de decisiones del equipo de desarrollo (o del arquitecto, esta responsabilidad tiene su propio rol)

No existe una arquitectura ideal, todas ofrecen ventajas y desventajas. Todo depende del contexto espec√≠fico del problema y la soluci√≥n deseada.

Por ejemplo, la arquitectura MVC ofrece un dise√±o muy simplificado del funcionamiento real de una aplicaci√≥n y ofrece ciertas ventajas:

- Permite crear implementaciones r√°pidas, √∫til al crear un MVP o validar una idea
- Facilita el desarrollo de soluciones sencillas
- F√°cil de aplicar y entender

Sin embargo, para problemas m√°s complejos que contienen mucha l√≥gica de negocio, integraciones con terceros y m√∫ltiples fuentes de datos este patr√≥n se vuelve muy dif√≠cil de mantener, probar y escalar debido a sus limitaciones de dise√±o.

Idealmente conviene aplicar MVC cuando tienes requerimientos sencillos o no planeas que sea durable en el tiempo

Patrones m√°s robustos y adaptables a gran escala se suelen llamar como **Clean Architecture** (Arquitecturas Limpias).

Aqu√≠ destacan 3: **Hexagonal**, **Onion** y **Clean** y son ideales cuando necesitas mantenibilidad y escalabilidad.

 Por supuesto, merecen su propio post donde hablar√© de ellas m√°s a detalle